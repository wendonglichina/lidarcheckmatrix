// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "sensor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace SensorProto {

namespace {

const ::google::protobuf::Descriptor* IMUFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IMUFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPSFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPSFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPSFrameRaw_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPSFrameRaw_reflection_ = NULL;
const ::google::protobuf::Descriptor* LidarBaseInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LidarBaseInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* VelodyneLaserParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VelodyneLaserParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* VelodyneLasers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VelodyneLasers_reflection_ = NULL;
const ::google::protobuf::Descriptor* VelodyneParmas_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VelodyneParmas_reflection_ = NULL;
const ::google::protobuf::Descriptor* VelodyneFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VelodyneFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobosenseParmas_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobosenseParmas_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobosenseFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobosenseFrame_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_sensor_2eproto() {
  protobuf_AddDesc_sensor_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "sensor.proto");
  GOOGLE_CHECK(file != NULL);
  IMUFrame_descriptor_ = file->message_type(0);
  static const int IMUFrame_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, acc_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, acc_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, acc_z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, gyro_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, gyro_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, gyro_z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, temperature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, time_stamp_),
  };
  IMUFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IMUFrame_descriptor_,
      IMUFrame::default_instance_,
      IMUFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IMUFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IMUFrame));
  GPSFrame_descriptor_ = file->message_type(1);
  static const int GPSFrame_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, longitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, latitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, longitude_cent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, longitude_dir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, latitude_cent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, latitude_dir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, ground_speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, ground_course_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, gps_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, altitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, accuracy_),
  };
  GPSFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPSFrame_descriptor_,
      GPSFrame::default_instance_,
      GPSFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPSFrame));
  GPSFrameRaw_descriptor_ = file->message_type(2);
  static const int GPSFrameRaw_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrameRaw, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrameRaw, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrameRaw, parsed_),
  };
  GPSFrameRaw_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPSFrameRaw_descriptor_,
      GPSFrameRaw::default_instance_,
      GPSFrameRaw_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrameRaw, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPSFrameRaw, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPSFrameRaw));
  LidarBaseInfo_descriptor_ = file->message_type(3);
  static const int LidarBaseInfo_offsets_[21] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, vendor_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, rpm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, time_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, repeat_delay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, max_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, min_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, view_direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, view_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, min_angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, max_angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, packet_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, pitch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, roll_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, x_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, y_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, z_offset_),
  };
  LidarBaseInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LidarBaseInfo_descriptor_,
      LidarBaseInfo::default_instance_,
      LidarBaseInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarBaseInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LidarBaseInfo));
  VelodyneLaserParam_descriptor_ = file->message_type(4);
  static const int VelodyneLaserParam_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, dist_correction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, dist_correction_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, dist_correction_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, focal_distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, focal_slope_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, horiz_offset_correction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, rot_correction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, vert_correction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, vert_offset_correction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, max_intensity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, min_intensity_),
  };
  VelodyneLaserParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VelodyneLaserParam_descriptor_,
      VelodyneLaserParam::default_instance_,
      VelodyneLaserParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLaserParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VelodyneLaserParam));
  VelodyneLasers_descriptor_ = file->message_type(5);
  static const int VelodyneLasers_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLasers, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLasers, param_),
  };
  VelodyneLasers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VelodyneLasers_descriptor_,
      VelodyneLasers::default_instance_,
      VelodyneLasers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLasers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneLasers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VelodyneLasers));
  VelodyneParmas_descriptor_ = file->message_type(6);
  static const int VelodyneParmas_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneParmas, base_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneParmas, lasers_),
  };
  VelodyneParmas_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VelodyneParmas_descriptor_,
      VelodyneParmas::default_instance_,
      VelodyneParmas_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneParmas, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneParmas, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VelodyneParmas));
  VelodyneFrame_descriptor_ = file->message_type(7);
  static const int VelodyneFrame_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneFrame, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneFrame, parms_),
  };
  VelodyneFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VelodyneFrame_descriptor_,
      VelodyneFrame::default_instance_,
      VelodyneFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VelodyneFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VelodyneFrame));
  RobosenseParmas_descriptor_ = file->message_type(8);
  static const int RobosenseParmas_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseParmas, base_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseParmas, server_ip_),
  };
  RobosenseParmas_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobosenseParmas_descriptor_,
      RobosenseParmas::default_instance_,
      RobosenseParmas_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseParmas, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseParmas, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobosenseParmas));
  RobosenseFrame_descriptor_ = file->message_type(9);
  static const int RobosenseFrame_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseFrame, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseFrame, parms_),
  };
  RobosenseFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobosenseFrame_descriptor_,
      RobosenseFrame::default_instance_,
      RobosenseFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobosenseFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobosenseFrame));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_sensor_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IMUFrame_descriptor_, &IMUFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPSFrame_descriptor_, &GPSFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPSFrameRaw_descriptor_, &GPSFrameRaw::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LidarBaseInfo_descriptor_, &LidarBaseInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VelodyneLaserParam_descriptor_, &VelodyneLaserParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VelodyneLasers_descriptor_, &VelodyneLasers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VelodyneParmas_descriptor_, &VelodyneParmas::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VelodyneFrame_descriptor_, &VelodyneFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobosenseParmas_descriptor_, &RobosenseParmas::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobosenseFrame_descriptor_, &RobosenseFrame::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_sensor_2eproto() {
  delete IMUFrame::default_instance_;
  delete IMUFrame_reflection_;
  delete GPSFrame::default_instance_;
  delete GPSFrame_reflection_;
  delete GPSFrameRaw::default_instance_;
  delete GPSFrameRaw_reflection_;
  delete LidarBaseInfo::default_instance_;
  delete LidarBaseInfo_reflection_;
  delete VelodyneLaserParam::default_instance_;
  delete VelodyneLaserParam_reflection_;
  delete VelodyneLasers::default_instance_;
  delete VelodyneLasers_reflection_;
  delete VelodyneParmas::default_instance_;
  delete VelodyneParmas_reflection_;
  delete VelodyneFrame::default_instance_;
  delete VelodyneFrame_reflection_;
  delete RobosenseParmas::default_instance_;
  delete RobosenseParmas_reflection_;
  delete RobosenseFrame::default_instance_;
  delete RobosenseFrame_reflection_;
}

void protobuf_AddDesc_sensor_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014sensor.proto\022\013SensorProto\"\220\001\n\010IMUFrame"
    "\022\r\n\005acc_x\030\001 \001(\002\022\r\n\005acc_y\030\002 \001(\002\022\r\n\005acc_z\030"
    "\003 \001(\002\022\016\n\006gyro_x\030\004 \001(\002\022\016\n\006gyro_y\030\005 \001(\002\022\016\n"
    "\006gyro_z\030\006 \001(\002\022\023\n\013temperature\030\007 \001(\002\022\022\n\nti"
    "me_stamp\030\010 \002(\003\"\202\002\n\010GPSFrame\022\021\n\tlongitude"
    "\030\001 \002(\002\022\020\n\010latitude\030\002 \002(\002\022\022\n\ntime_stamp\030\003"
    " \002(\003\022\026\n\016longitude_cent\030\004 \001(\002\022\025\n\rlongitud"
    "e_dir\030\005 \001(\t\022\025\n\rlatitude_cent\030\006 \001(\002\022\024\n\014la"
    "titude_dir\030\007 \001(\t\022\024\n\014ground_speed\030\010 \001(\002\022\025"
    "\n\rground_course\030\t \001(\002\022\020\n\010gps_time\030\n \001(\003\022"
    "\020\n\010altitude\030\013 \001(\002\022\020\n\010accuracy\030\014 \001(\002\"V\n\013G"
    "PSFrameRaw\022\014\n\004info\030\001 \001(\t\022\022\n\ntime_stamp\030\002"
    " \002(\003\022%\n\006parsed\030\003 \001(\0132\025.SensorProto.GPSFr"
    "ame\"\200\003\n\rLidarBaseInfo\022\023\n\013vendor_name\030\001 \001"
    "(\t\022\r\n\005model\030\002 \001(\t\022\n\n\002ip\030\003 \001(\t\022\014\n\004desc\030\004 "
    "\001(\t\022\014\n\004port\030\005 \001(\003\022\013\n\003rpm\030\006 \001(\002\022\023\n\013time_o"
    "ffset\030\007 \001(\002\022\024\n\014repeat_delay\030\010 \001(\002\022\021\n\tmax"
    "_range\030\t \001(\002\022\021\n\tmin_range\030\n \001(\002\022\026\n\016view_"
    "direction\030\013 \001(\002\022\022\n\nview_width\030\014 \001(\002\022\021\n\tm"
    "in_angle\030\r \001(\002\022\021\n\tmax_angle\030\016 \001(\002\022\023\n\013pac"
    "ket_rate\030\017 \001(\002\022\r\n\005pitch\030\020 \001(\002\022\013\n\003yaw\030\021 \001"
    "(\002\022\014\n\004roll\030\022 \001(\002\022\020\n\010x_offset\030\023 \001(\002\022\020\n\010y_"
    "offset\030\024 \001(\002\022\020\n\010z_offset\030\025 \001(\002\"\274\002\n\022Velod"
    "yneLaserParam\022\n\n\002id\030\001 \001(\005\022\027\n\017dist_correc"
    "tion\030\002 \001(\002\022\031\n\021dist_correction_x\030\003 \001(\002\022\031\n"
    "\021dist_correction_y\030\004 \001(\002\022\026\n\016focal_distan"
    "ce\030\005 \001(\002\022\023\n\013focal_slope\030\006 \001(\002\022\037\n\027horiz_o"
    "ffset_correction\030\007 \001(\002\022\026\n\016rot_correction"
    "\030\010 \001(\002\022\027\n\017vert_correction\030\t \001(\002\022\036\n\026vert_"
    "offset_correction\030\n \001(\002\022\025\n\rmax_intensity"
    "\030\013 \001(\002\022\025\n\rmin_intensity\030\014 \001(\002\"M\n\016Velodyn"
    "eLasers\022\013\n\003num\030\001 \001(\005\022.\n\005param\030\002 \003(\0132\037.Se"
    "nsorProto.VelodyneLaserParam\"l\n\016Velodyne"
    "Parmas\022-\n\tbase_info\030\001 \001(\0132\032.SensorProto."
    "LidarBaseInfo\022+\n\006lasers\030\002 \001(\0132\033.SensorPr"
    "oto.VelodyneLasers\"O\n\rVelodyneFrame\022\022\n\nt"
    "ime_stamp\030\001 \002(\003\022*\n\005parms\030\002 \001(\0132\033.SensorP"
    "roto.VelodyneParmas\"S\n\017RobosenseParmas\022-"
    "\n\tbase_info\030\001 \001(\0132\032.SensorProto.LidarBas"
    "eInfo\022\021\n\tserver_ip\030\002 \001(\t\"Q\n\016RobosenseFra"
    "me\022\022\n\ntime_stamp\030\001 \002(\003\022+\n\005parms\030\002 \001(\0132\034."
    "SensorProto.RobosenseParmas", 1667);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "sensor.proto", &protobuf_RegisterTypes);
  IMUFrame::default_instance_ = new IMUFrame();
  GPSFrame::default_instance_ = new GPSFrame();
  GPSFrameRaw::default_instance_ = new GPSFrameRaw();
  LidarBaseInfo::default_instance_ = new LidarBaseInfo();
  VelodyneLaserParam::default_instance_ = new VelodyneLaserParam();
  VelodyneLasers::default_instance_ = new VelodyneLasers();
  VelodyneParmas::default_instance_ = new VelodyneParmas();
  VelodyneFrame::default_instance_ = new VelodyneFrame();
  RobosenseParmas::default_instance_ = new RobosenseParmas();
  RobosenseFrame::default_instance_ = new RobosenseFrame();
  IMUFrame::default_instance_->InitAsDefaultInstance();
  GPSFrame::default_instance_->InitAsDefaultInstance();
  GPSFrameRaw::default_instance_->InitAsDefaultInstance();
  LidarBaseInfo::default_instance_->InitAsDefaultInstance();
  VelodyneLaserParam::default_instance_->InitAsDefaultInstance();
  VelodyneLasers::default_instance_->InitAsDefaultInstance();
  VelodyneParmas::default_instance_->InitAsDefaultInstance();
  VelodyneFrame::default_instance_->InitAsDefaultInstance();
  RobosenseParmas::default_instance_->InitAsDefaultInstance();
  RobosenseFrame::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_sensor_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_sensor_2eproto {
  StaticDescriptorInitializer_sensor_2eproto() {
    protobuf_AddDesc_sensor_2eproto();
  }
} static_descriptor_initializer_sensor_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int IMUFrame::kAccXFieldNumber;
const int IMUFrame::kAccYFieldNumber;
const int IMUFrame::kAccZFieldNumber;
const int IMUFrame::kGyroXFieldNumber;
const int IMUFrame::kGyroYFieldNumber;
const int IMUFrame::kGyroZFieldNumber;
const int IMUFrame::kTemperatureFieldNumber;
const int IMUFrame::kTimeStampFieldNumber;
#endif  // !_MSC_VER

IMUFrame::IMUFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.IMUFrame)
}

void IMUFrame::InitAsDefaultInstance() {
}

IMUFrame::IMUFrame(const IMUFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.IMUFrame)
}

void IMUFrame::SharedCtor() {
  _cached_size_ = 0;
  acc_x_ = 0;
  acc_y_ = 0;
  acc_z_ = 0;
  gyro_x_ = 0;
  gyro_y_ = 0;
  gyro_z_ = 0;
  temperature_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUFrame::~IMUFrame() {
  // @@protoc_insertion_point(destructor:SensorProto.IMUFrame)
  SharedDtor();
}

void IMUFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IMUFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IMUFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IMUFrame_descriptor_;
}

const IMUFrame& IMUFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

IMUFrame* IMUFrame::default_instance_ = NULL;

IMUFrame* IMUFrame::New() const {
  return new IMUFrame;
}

void IMUFrame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMUFrame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(acc_x_, temperature_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IMUFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.IMUFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float acc_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_x_)));
          set_has_acc_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_acc_y;
        break;
      }

      // optional float acc_y = 2;
      case 2: {
        if (tag == 21) {
         parse_acc_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_y_)));
          set_has_acc_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_acc_z;
        break;
      }

      // optional float acc_z = 3;
      case 3: {
        if (tag == 29) {
         parse_acc_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_z_)));
          set_has_acc_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_gyro_x;
        break;
      }

      // optional float gyro_x = 4;
      case 4: {
        if (tag == 37) {
         parse_gyro_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro_x_)));
          set_has_gyro_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_gyro_y;
        break;
      }

      // optional float gyro_y = 5;
      case 5: {
        if (tag == 45) {
         parse_gyro_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro_y_)));
          set_has_gyro_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_gyro_z;
        break;
      }

      // optional float gyro_z = 6;
      case 6: {
        if (tag == 53) {
         parse_gyro_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro_z_)));
          set_has_gyro_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_temperature;
        break;
      }

      // optional float temperature = 7;
      case 7: {
        if (tag == 61) {
         parse_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
          set_has_temperature();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 8;
      case 8: {
        if (tag == 64) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.IMUFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.IMUFrame)
  return false;
#undef DO_
}

void IMUFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.IMUFrame)
  // optional float acc_x = 1;
  if (has_acc_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->acc_x(), output);
  }

  // optional float acc_y = 2;
  if (has_acc_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->acc_y(), output);
  }

  // optional float acc_z = 3;
  if (has_acc_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->acc_z(), output);
  }

  // optional float gyro_x = 4;
  if (has_gyro_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->gyro_x(), output);
  }

  // optional float gyro_y = 5;
  if (has_gyro_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->gyro_y(), output);
  }

  // optional float gyro_z = 6;
  if (has_gyro_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->gyro_z(), output);
  }

  // optional float temperature = 7;
  if (has_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->temperature(), output);
  }

  // required int64 time_stamp = 8;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.IMUFrame)
}

::google::protobuf::uint8* IMUFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.IMUFrame)
  // optional float acc_x = 1;
  if (has_acc_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->acc_x(), target);
  }

  // optional float acc_y = 2;
  if (has_acc_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->acc_y(), target);
  }

  // optional float acc_z = 3;
  if (has_acc_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->acc_z(), target);
  }

  // optional float gyro_x = 4;
  if (has_gyro_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->gyro_x(), target);
  }

  // optional float gyro_y = 5;
  if (has_gyro_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->gyro_y(), target);
  }

  // optional float gyro_z = 6;
  if (has_gyro_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->gyro_z(), target);
  }

  // optional float temperature = 7;
  if (has_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->temperature(), target);
  }

  // required int64 time_stamp = 8;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.IMUFrame)
  return target;
}

int IMUFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float acc_x = 1;
    if (has_acc_x()) {
      total_size += 1 + 4;
    }

    // optional float acc_y = 2;
    if (has_acc_y()) {
      total_size += 1 + 4;
    }

    // optional float acc_z = 3;
    if (has_acc_z()) {
      total_size += 1 + 4;
    }

    // optional float gyro_x = 4;
    if (has_gyro_x()) {
      total_size += 1 + 4;
    }

    // optional float gyro_y = 5;
    if (has_gyro_y()) {
      total_size += 1 + 4;
    }

    // optional float gyro_z = 6;
    if (has_gyro_z()) {
      total_size += 1 + 4;
    }

    // optional float temperature = 7;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

    // required int64 time_stamp = 8;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IMUFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IMUFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IMUFrame::MergeFrom(const IMUFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_x()) {
      set_acc_x(from.acc_x());
    }
    if (from.has_acc_y()) {
      set_acc_y(from.acc_y());
    }
    if (from.has_acc_z()) {
      set_acc_z(from.acc_z());
    }
    if (from.has_gyro_x()) {
      set_gyro_x(from.gyro_x());
    }
    if (from.has_gyro_y()) {
      set_gyro_y(from.gyro_y());
    }
    if (from.has_gyro_z()) {
      set_gyro_z(from.gyro_z());
    }
    if (from.has_temperature()) {
      set_temperature(from.temperature());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IMUFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IMUFrame::CopyFrom(const IMUFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000080) != 0x00000080) return false;

  return true;
}

void IMUFrame::Swap(IMUFrame* other) {
  if (other != this) {
    std::swap(acc_x_, other->acc_x_);
    std::swap(acc_y_, other->acc_y_);
    std::swap(acc_z_, other->acc_z_);
    std::swap(gyro_x_, other->gyro_x_);
    std::swap(gyro_y_, other->gyro_y_);
    std::swap(gyro_z_, other->gyro_z_);
    std::swap(temperature_, other->temperature_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IMUFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IMUFrame_descriptor_;
  metadata.reflection = IMUFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPSFrame::kLongitudeFieldNumber;
const int GPSFrame::kLatitudeFieldNumber;
const int GPSFrame::kTimeStampFieldNumber;
const int GPSFrame::kLongitudeCentFieldNumber;
const int GPSFrame::kLongitudeDirFieldNumber;
const int GPSFrame::kLatitudeCentFieldNumber;
const int GPSFrame::kLatitudeDirFieldNumber;
const int GPSFrame::kGroundSpeedFieldNumber;
const int GPSFrame::kGroundCourseFieldNumber;
const int GPSFrame::kGpsTimeFieldNumber;
const int GPSFrame::kAltitudeFieldNumber;
const int GPSFrame::kAccuracyFieldNumber;
#endif  // !_MSC_VER

GPSFrame::GPSFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.GPSFrame)
}

void GPSFrame::InitAsDefaultInstance() {
}

GPSFrame::GPSFrame(const GPSFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.GPSFrame)
}

void GPSFrame::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  longitude_ = 0;
  latitude_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  longitude_cent_ = 0;
  longitude_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  latitude_cent_ = 0;
  latitude_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ground_speed_ = 0;
  ground_course_ = 0;
  gps_time_ = GOOGLE_LONGLONG(0);
  altitude_ = 0;
  accuracy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPSFrame::~GPSFrame() {
  // @@protoc_insertion_point(destructor:SensorProto.GPSFrame)
  SharedDtor();
}

void GPSFrame::SharedDtor() {
  if (longitude_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete longitude_dir_;
  }
  if (latitude_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latitude_dir_;
  }
  if (this != default_instance_) {
  }
}

void GPSFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPSFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPSFrame_descriptor_;
}

const GPSFrame& GPSFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

GPSFrame* GPSFrame::default_instance_ = NULL;

GPSFrame* GPSFrame::New() const {
  return new GPSFrame;
}

void GPSFrame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GPSFrame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(longitude_, time_stamp_);
    ZR_(longitude_cent_, latitude_cent_);
    if (has_longitude_dir()) {
      if (longitude_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        longitude_dir_->clear();
      }
    }
    if (has_latitude_dir()) {
      if (latitude_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        latitude_dir_->clear();
      }
    }
    ground_speed_ = 0;
  }
  ZR_(ground_course_, accuracy_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPSFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.GPSFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float longitude = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitude_)));
          set_has_longitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_latitude;
        break;
      }

      // required float latitude = 2;
      case 2: {
        if (tag == 21) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &latitude_)));
          set_has_latitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_longitude_cent;
        break;
      }

      // optional float longitude_cent = 4;
      case 4: {
        if (tag == 37) {
         parse_longitude_cent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitude_cent_)));
          set_has_longitude_cent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_longitude_dir;
        break;
      }

      // optional string longitude_dir = 5;
      case 5: {
        if (tag == 42) {
         parse_longitude_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_longitude_dir()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->longitude_dir().data(), this->longitude_dir().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "longitude_dir");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_latitude_cent;
        break;
      }

      // optional float latitude_cent = 6;
      case 6: {
        if (tag == 53) {
         parse_latitude_cent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &latitude_cent_)));
          set_has_latitude_cent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_latitude_dir;
        break;
      }

      // optional string latitude_dir = 7;
      case 7: {
        if (tag == 58) {
         parse_latitude_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_latitude_dir()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->latitude_dir().data(), this->latitude_dir().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "latitude_dir");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_ground_speed;
        break;
      }

      // optional float ground_speed = 8;
      case 8: {
        if (tag == 69) {
         parse_ground_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ground_speed_)));
          set_has_ground_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_ground_course;
        break;
      }

      // optional float ground_course = 9;
      case 9: {
        if (tag == 77) {
         parse_ground_course:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ground_course_)));
          set_has_ground_course();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_gps_time;
        break;
      }

      // optional int64 gps_time = 10;
      case 10: {
        if (tag == 80) {
         parse_gps_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gps_time_)));
          set_has_gps_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_altitude;
        break;
      }

      // optional float altitude = 11;
      case 11: {
        if (tag == 93) {
         parse_altitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &altitude_)));
          set_has_altitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_accuracy;
        break;
      }

      // optional float accuracy = 12;
      case 12: {
        if (tag == 101) {
         parse_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &accuracy_)));
          set_has_accuracy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.GPSFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.GPSFrame)
  return false;
#undef DO_
}

void GPSFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.GPSFrame)
  // required float longitude = 1;
  if (has_longitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->longitude(), output);
  }

  // required float latitude = 2;
  if (has_latitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->latitude(), output);
  }

  // required int64 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->time_stamp(), output);
  }

  // optional float longitude_cent = 4;
  if (has_longitude_cent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->longitude_cent(), output);
  }

  // optional string longitude_dir = 5;
  if (has_longitude_dir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->longitude_dir().data(), this->longitude_dir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "longitude_dir");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->longitude_dir(), output);
  }

  // optional float latitude_cent = 6;
  if (has_latitude_cent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->latitude_cent(), output);
  }

  // optional string latitude_dir = 7;
  if (has_latitude_dir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->latitude_dir().data(), this->latitude_dir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "latitude_dir");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->latitude_dir(), output);
  }

  // optional float ground_speed = 8;
  if (has_ground_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->ground_speed(), output);
  }

  // optional float ground_course = 9;
  if (has_ground_course()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->ground_course(), output);
  }

  // optional int64 gps_time = 10;
  if (has_gps_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->gps_time(), output);
  }

  // optional float altitude = 11;
  if (has_altitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->altitude(), output);
  }

  // optional float accuracy = 12;
  if (has_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->accuracy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.GPSFrame)
}

::google::protobuf::uint8* GPSFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.GPSFrame)
  // required float longitude = 1;
  if (has_longitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->longitude(), target);
  }

  // required float latitude = 2;
  if (has_latitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->latitude(), target);
  }

  // required int64 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->time_stamp(), target);
  }

  // optional float longitude_cent = 4;
  if (has_longitude_cent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->longitude_cent(), target);
  }

  // optional string longitude_dir = 5;
  if (has_longitude_dir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->longitude_dir().data(), this->longitude_dir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "longitude_dir");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->longitude_dir(), target);
  }

  // optional float latitude_cent = 6;
  if (has_latitude_cent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->latitude_cent(), target);
  }

  // optional string latitude_dir = 7;
  if (has_latitude_dir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->latitude_dir().data(), this->latitude_dir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "latitude_dir");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->latitude_dir(), target);
  }

  // optional float ground_speed = 8;
  if (has_ground_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->ground_speed(), target);
  }

  // optional float ground_course = 9;
  if (has_ground_course()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->ground_course(), target);
  }

  // optional int64 gps_time = 10;
  if (has_gps_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->gps_time(), target);
  }

  // optional float altitude = 11;
  if (has_altitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->altitude(), target);
  }

  // optional float accuracy = 12;
  if (has_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->accuracy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.GPSFrame)
  return target;
}

int GPSFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float longitude = 1;
    if (has_longitude()) {
      total_size += 1 + 4;
    }

    // required float latitude = 2;
    if (has_latitude()) {
      total_size += 1 + 4;
    }

    // required int64 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional float longitude_cent = 4;
    if (has_longitude_cent()) {
      total_size += 1 + 4;
    }

    // optional string longitude_dir = 5;
    if (has_longitude_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->longitude_dir());
    }

    // optional float latitude_cent = 6;
    if (has_latitude_cent()) {
      total_size += 1 + 4;
    }

    // optional string latitude_dir = 7;
    if (has_latitude_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->latitude_dir());
    }

    // optional float ground_speed = 8;
    if (has_ground_speed()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float ground_course = 9;
    if (has_ground_course()) {
      total_size += 1 + 4;
    }

    // optional int64 gps_time = 10;
    if (has_gps_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gps_time());
    }

    // optional float altitude = 11;
    if (has_altitude()) {
      total_size += 1 + 4;
    }

    // optional float accuracy = 12;
    if (has_accuracy()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPSFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPSFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPSFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPSFrame::MergeFrom(const GPSFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_longitude()) {
      set_longitude(from.longitude());
    }
    if (from.has_latitude()) {
      set_latitude(from.latitude());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_longitude_cent()) {
      set_longitude_cent(from.longitude_cent());
    }
    if (from.has_longitude_dir()) {
      set_longitude_dir(from.longitude_dir());
    }
    if (from.has_latitude_cent()) {
      set_latitude_cent(from.latitude_cent());
    }
    if (from.has_latitude_dir()) {
      set_latitude_dir(from.latitude_dir());
    }
    if (from.has_ground_speed()) {
      set_ground_speed(from.ground_speed());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ground_course()) {
      set_ground_course(from.ground_course());
    }
    if (from.has_gps_time()) {
      set_gps_time(from.gps_time());
    }
    if (from.has_altitude()) {
      set_altitude(from.altitude());
    }
    if (from.has_accuracy()) {
      set_accuracy(from.accuracy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPSFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPSFrame::CopyFrom(const GPSFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPSFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GPSFrame::Swap(GPSFrame* other) {
  if (other != this) {
    std::swap(longitude_, other->longitude_);
    std::swap(latitude_, other->latitude_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(longitude_cent_, other->longitude_cent_);
    std::swap(longitude_dir_, other->longitude_dir_);
    std::swap(latitude_cent_, other->latitude_cent_);
    std::swap(latitude_dir_, other->latitude_dir_);
    std::swap(ground_speed_, other->ground_speed_);
    std::swap(ground_course_, other->ground_course_);
    std::swap(gps_time_, other->gps_time_);
    std::swap(altitude_, other->altitude_);
    std::swap(accuracy_, other->accuracy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPSFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPSFrame_descriptor_;
  metadata.reflection = GPSFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPSFrameRaw::kInfoFieldNumber;
const int GPSFrameRaw::kTimeStampFieldNumber;
const int GPSFrameRaw::kParsedFieldNumber;
#endif  // !_MSC_VER

GPSFrameRaw::GPSFrameRaw()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.GPSFrameRaw)
}

void GPSFrameRaw::InitAsDefaultInstance() {
  parsed_ = const_cast< ::SensorProto::GPSFrame*>(&::SensorProto::GPSFrame::default_instance());
}

GPSFrameRaw::GPSFrameRaw(const GPSFrameRaw& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.GPSFrameRaw)
}

void GPSFrameRaw::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_stamp_ = GOOGLE_LONGLONG(0);
  parsed_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPSFrameRaw::~GPSFrameRaw() {
  // @@protoc_insertion_point(destructor:SensorProto.GPSFrameRaw)
  SharedDtor();
}

void GPSFrameRaw::SharedDtor() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (this != default_instance_) {
    delete parsed_;
  }
}

void GPSFrameRaw::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPSFrameRaw::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPSFrameRaw_descriptor_;
}

const GPSFrameRaw& GPSFrameRaw::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

GPSFrameRaw* GPSFrameRaw::default_instance_ = NULL;

GPSFrameRaw* GPSFrameRaw::New() const {
  return new GPSFrameRaw;
}

void GPSFrameRaw::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_info()) {
      if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        info_->clear();
      }
    }
    time_stamp_ = GOOGLE_LONGLONG(0);
    if (has_parsed()) {
      if (parsed_ != NULL) parsed_->::SensorProto::GPSFrame::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPSFrameRaw::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.GPSFrameRaw)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_info()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->info().data(), this->info().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "info");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_parsed;
        break;
      }

      // optional .SensorProto.GPSFrame parsed = 3;
      case 3: {
        if (tag == 26) {
         parse_parsed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parsed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.GPSFrameRaw)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.GPSFrameRaw)
  return false;
#undef DO_
}

void GPSFrameRaw::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.GPSFrameRaw)
  // optional string info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "info");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->info(), output);
  }

  // required int64 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->time_stamp(), output);
  }

  // optional .SensorProto.GPSFrame parsed = 3;
  if (has_parsed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->parsed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.GPSFrameRaw)
}

::google::protobuf::uint8* GPSFrameRaw::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.GPSFrameRaw)
  // optional string info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "info");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->info(), target);
  }

  // required int64 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->time_stamp(), target);
  }

  // optional .SensorProto.GPSFrame parsed = 3;
  if (has_parsed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->parsed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.GPSFrameRaw)
  return target;
}

int GPSFrameRaw::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->info());
    }

    // required int64 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional .SensorProto.GPSFrame parsed = 3;
    if (has_parsed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parsed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPSFrameRaw::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPSFrameRaw* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPSFrameRaw*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPSFrameRaw::MergeFrom(const GPSFrameRaw& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      set_info(from.info());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_parsed()) {
      mutable_parsed()->::SensorProto::GPSFrame::MergeFrom(from.parsed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPSFrameRaw::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPSFrameRaw::CopyFrom(const GPSFrameRaw& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPSFrameRaw::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_parsed()) {
    if (!this->parsed().IsInitialized()) return false;
  }
  return true;
}

void GPSFrameRaw::Swap(GPSFrameRaw* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(parsed_, other->parsed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPSFrameRaw::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPSFrameRaw_descriptor_;
  metadata.reflection = GPSFrameRaw_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LidarBaseInfo::kVendorNameFieldNumber;
const int LidarBaseInfo::kModelFieldNumber;
const int LidarBaseInfo::kIpFieldNumber;
const int LidarBaseInfo::kDescFieldNumber;
const int LidarBaseInfo::kPortFieldNumber;
const int LidarBaseInfo::kRpmFieldNumber;
const int LidarBaseInfo::kTimeOffsetFieldNumber;
const int LidarBaseInfo::kRepeatDelayFieldNumber;
const int LidarBaseInfo::kMaxRangeFieldNumber;
const int LidarBaseInfo::kMinRangeFieldNumber;
const int LidarBaseInfo::kViewDirectionFieldNumber;
const int LidarBaseInfo::kViewWidthFieldNumber;
const int LidarBaseInfo::kMinAngleFieldNumber;
const int LidarBaseInfo::kMaxAngleFieldNumber;
const int LidarBaseInfo::kPacketRateFieldNumber;
const int LidarBaseInfo::kPitchFieldNumber;
const int LidarBaseInfo::kYawFieldNumber;
const int LidarBaseInfo::kRollFieldNumber;
const int LidarBaseInfo::kXOffsetFieldNumber;
const int LidarBaseInfo::kYOffsetFieldNumber;
const int LidarBaseInfo::kZOffsetFieldNumber;
#endif  // !_MSC_VER

LidarBaseInfo::LidarBaseInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.LidarBaseInfo)
}

void LidarBaseInfo::InitAsDefaultInstance() {
}

LidarBaseInfo::LidarBaseInfo(const LidarBaseInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.LidarBaseInfo)
}

void LidarBaseInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  vendor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = GOOGLE_LONGLONG(0);
  rpm_ = 0;
  time_offset_ = 0;
  repeat_delay_ = 0;
  max_range_ = 0;
  min_range_ = 0;
  view_direction_ = 0;
  view_width_ = 0;
  min_angle_ = 0;
  max_angle_ = 0;
  packet_rate_ = 0;
  pitch_ = 0;
  yaw_ = 0;
  roll_ = 0;
  x_offset_ = 0;
  y_offset_ = 0;
  z_offset_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LidarBaseInfo::~LidarBaseInfo() {
  // @@protoc_insertion_point(destructor:SensorProto.LidarBaseInfo)
  SharedDtor();
}

void LidarBaseInfo::SharedDtor() {
  if (vendor_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_name_;
  }
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void LidarBaseInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LidarBaseInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LidarBaseInfo_descriptor_;
}

const LidarBaseInfo& LidarBaseInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

LidarBaseInfo* LidarBaseInfo::default_instance_ = NULL;

LidarBaseInfo* LidarBaseInfo::New() const {
  return new LidarBaseInfo;
}

void LidarBaseInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LidarBaseInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(port_, repeat_delay_);
    if (has_vendor_name()) {
      if (vendor_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vendor_name_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        model_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        desc_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(max_range_, pitch_);
  }
  if (_has_bits_[16 / 32] & 2031616) {
    ZR_(yaw_, z_offset_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LidarBaseInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.LidarBaseInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string vendor_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vendor_name().data(), this->vendor_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vendor_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_model;
        break;
      }

      // optional string model = 2;
      case 2: {
        if (tag == 18) {
         parse_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "model");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }

      // optional string ip = 3;
      case 3: {
        if (tag == 26) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_desc;
        break;
      }

      // optional string desc = 4;
      case 4: {
        if (tag == 34) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "desc");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_port;
        break;
      }

      // optional int64 port = 5;
      case 5: {
        if (tag == 40) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_rpm;
        break;
      }

      // optional float rpm = 6;
      case 6: {
        if (tag == 53) {
         parse_rpm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rpm_)));
          set_has_rpm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_time_offset;
        break;
      }

      // optional float time_offset = 7;
      case 7: {
        if (tag == 61) {
         parse_time_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_offset_)));
          set_has_time_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_repeat_delay;
        break;
      }

      // optional float repeat_delay = 8;
      case 8: {
        if (tag == 69) {
         parse_repeat_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &repeat_delay_)));
          set_has_repeat_delay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_max_range;
        break;
      }

      // optional float max_range = 9;
      case 9: {
        if (tag == 77) {
         parse_max_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_range_)));
          set_has_max_range();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_min_range;
        break;
      }

      // optional float min_range = 10;
      case 10: {
        if (tag == 85) {
         parse_min_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_range_)));
          set_has_min_range();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_view_direction;
        break;
      }

      // optional float view_direction = 11;
      case 11: {
        if (tag == 93) {
         parse_view_direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &view_direction_)));
          set_has_view_direction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_view_width;
        break;
      }

      // optional float view_width = 12;
      case 12: {
        if (tag == 101) {
         parse_view_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &view_width_)));
          set_has_view_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(109)) goto parse_min_angle;
        break;
      }

      // optional float min_angle = 13;
      case 13: {
        if (tag == 109) {
         parse_min_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_angle_)));
          set_has_min_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(117)) goto parse_max_angle;
        break;
      }

      // optional float max_angle = 14;
      case 14: {
        if (tag == 117) {
         parse_max_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_angle_)));
          set_has_max_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(125)) goto parse_packet_rate;
        break;
      }

      // optional float packet_rate = 15;
      case 15: {
        if (tag == 125) {
         parse_packet_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &packet_rate_)));
          set_has_packet_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(133)) goto parse_pitch;
        break;
      }

      // optional float pitch = 16;
      case 16: {
        if (tag == 133) {
         parse_pitch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pitch_)));
          set_has_pitch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(141)) goto parse_yaw;
        break;
      }

      // optional float yaw = 17;
      case 17: {
        if (tag == 141) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(149)) goto parse_roll;
        break;
      }

      // optional float roll = 18;
      case 18: {
        if (tag == 149) {
         parse_roll:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roll_)));
          set_has_roll();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(157)) goto parse_x_offset;
        break;
      }

      // optional float x_offset = 19;
      case 19: {
        if (tag == 157) {
         parse_x_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_offset_)));
          set_has_x_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(165)) goto parse_y_offset;
        break;
      }

      // optional float y_offset = 20;
      case 20: {
        if (tag == 165) {
         parse_y_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_offset_)));
          set_has_y_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(173)) goto parse_z_offset;
        break;
      }

      // optional float z_offset = 21;
      case 21: {
        if (tag == 173) {
         parse_z_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_offset_)));
          set_has_z_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.LidarBaseInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.LidarBaseInfo)
  return false;
#undef DO_
}

void LidarBaseInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.LidarBaseInfo)
  // optional string vendor_name = 1;
  if (has_vendor_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor_name().data(), this->vendor_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vendor_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vendor_name(), output);
  }

  // optional string model = 2;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->model(), output);
  }

  // optional string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->ip(), output);
  }

  // optional string desc = 4;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "desc");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->desc(), output);
  }

  // optional int64 port = 5;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->port(), output);
  }

  // optional float rpm = 6;
  if (has_rpm()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->rpm(), output);
  }

  // optional float time_offset = 7;
  if (has_time_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->time_offset(), output);
  }

  // optional float repeat_delay = 8;
  if (has_repeat_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->repeat_delay(), output);
  }

  // optional float max_range = 9;
  if (has_max_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->max_range(), output);
  }

  // optional float min_range = 10;
  if (has_min_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->min_range(), output);
  }

  // optional float view_direction = 11;
  if (has_view_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->view_direction(), output);
  }

  // optional float view_width = 12;
  if (has_view_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->view_width(), output);
  }

  // optional float min_angle = 13;
  if (has_min_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->min_angle(), output);
  }

  // optional float max_angle = 14;
  if (has_max_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->max_angle(), output);
  }

  // optional float packet_rate = 15;
  if (has_packet_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->packet_rate(), output);
  }

  // optional float pitch = 16;
  if (has_pitch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->pitch(), output);
  }

  // optional float yaw = 17;
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->yaw(), output);
  }

  // optional float roll = 18;
  if (has_roll()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->roll(), output);
  }

  // optional float x_offset = 19;
  if (has_x_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(19, this->x_offset(), output);
  }

  // optional float y_offset = 20;
  if (has_y_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(20, this->y_offset(), output);
  }

  // optional float z_offset = 21;
  if (has_z_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->z_offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.LidarBaseInfo)
}

::google::protobuf::uint8* LidarBaseInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.LidarBaseInfo)
  // optional string vendor_name = 1;
  if (has_vendor_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor_name().data(), this->vendor_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vendor_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vendor_name(), target);
  }

  // optional string model = 2;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->model(), target);
  }

  // optional string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ip(), target);
  }

  // optional string desc = 4;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "desc");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->desc(), target);
  }

  // optional int64 port = 5;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->port(), target);
  }

  // optional float rpm = 6;
  if (has_rpm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->rpm(), target);
  }

  // optional float time_offset = 7;
  if (has_time_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->time_offset(), target);
  }

  // optional float repeat_delay = 8;
  if (has_repeat_delay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->repeat_delay(), target);
  }

  // optional float max_range = 9;
  if (has_max_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->max_range(), target);
  }

  // optional float min_range = 10;
  if (has_min_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->min_range(), target);
  }

  // optional float view_direction = 11;
  if (has_view_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->view_direction(), target);
  }

  // optional float view_width = 12;
  if (has_view_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->view_width(), target);
  }

  // optional float min_angle = 13;
  if (has_min_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->min_angle(), target);
  }

  // optional float max_angle = 14;
  if (has_max_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->max_angle(), target);
  }

  // optional float packet_rate = 15;
  if (has_packet_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->packet_rate(), target);
  }

  // optional float pitch = 16;
  if (has_pitch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->pitch(), target);
  }

  // optional float yaw = 17;
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->yaw(), target);
  }

  // optional float roll = 18;
  if (has_roll()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(18, this->roll(), target);
  }

  // optional float x_offset = 19;
  if (has_x_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(19, this->x_offset(), target);
  }

  // optional float y_offset = 20;
  if (has_y_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(20, this->y_offset(), target);
  }

  // optional float z_offset = 21;
  if (has_z_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->z_offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.LidarBaseInfo)
  return target;
}

int LidarBaseInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string vendor_name = 1;
    if (has_vendor_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vendor_name());
    }

    // optional string model = 2;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }

    // optional string ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional string desc = 4;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }

    // optional int64 port = 5;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->port());
    }

    // optional float rpm = 6;
    if (has_rpm()) {
      total_size += 1 + 4;
    }

    // optional float time_offset = 7;
    if (has_time_offset()) {
      total_size += 1 + 4;
    }

    // optional float repeat_delay = 8;
    if (has_repeat_delay()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float max_range = 9;
    if (has_max_range()) {
      total_size += 1 + 4;
    }

    // optional float min_range = 10;
    if (has_min_range()) {
      total_size += 1 + 4;
    }

    // optional float view_direction = 11;
    if (has_view_direction()) {
      total_size += 1 + 4;
    }

    // optional float view_width = 12;
    if (has_view_width()) {
      total_size += 1 + 4;
    }

    // optional float min_angle = 13;
    if (has_min_angle()) {
      total_size += 1 + 4;
    }

    // optional float max_angle = 14;
    if (has_max_angle()) {
      total_size += 1 + 4;
    }

    // optional float packet_rate = 15;
    if (has_packet_rate()) {
      total_size += 1 + 4;
    }

    // optional float pitch = 16;
    if (has_pitch()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional float yaw = 17;
    if (has_yaw()) {
      total_size += 2 + 4;
    }

    // optional float roll = 18;
    if (has_roll()) {
      total_size += 2 + 4;
    }

    // optional float x_offset = 19;
    if (has_x_offset()) {
      total_size += 2 + 4;
    }

    // optional float y_offset = 20;
    if (has_y_offset()) {
      total_size += 2 + 4;
    }

    // optional float z_offset = 21;
    if (has_z_offset()) {
      total_size += 2 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LidarBaseInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LidarBaseInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LidarBaseInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LidarBaseInfo::MergeFrom(const LidarBaseInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vendor_name()) {
      set_vendor_name(from.vendor_name());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_rpm()) {
      set_rpm(from.rpm());
    }
    if (from.has_time_offset()) {
      set_time_offset(from.time_offset());
    }
    if (from.has_repeat_delay()) {
      set_repeat_delay(from.repeat_delay());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_max_range()) {
      set_max_range(from.max_range());
    }
    if (from.has_min_range()) {
      set_min_range(from.min_range());
    }
    if (from.has_view_direction()) {
      set_view_direction(from.view_direction());
    }
    if (from.has_view_width()) {
      set_view_width(from.view_width());
    }
    if (from.has_min_angle()) {
      set_min_angle(from.min_angle());
    }
    if (from.has_max_angle()) {
      set_max_angle(from.max_angle());
    }
    if (from.has_packet_rate()) {
      set_packet_rate(from.packet_rate());
    }
    if (from.has_pitch()) {
      set_pitch(from.pitch());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
    if (from.has_roll()) {
      set_roll(from.roll());
    }
    if (from.has_x_offset()) {
      set_x_offset(from.x_offset());
    }
    if (from.has_y_offset()) {
      set_y_offset(from.y_offset());
    }
    if (from.has_z_offset()) {
      set_z_offset(from.z_offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LidarBaseInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LidarBaseInfo::CopyFrom(const LidarBaseInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarBaseInfo::IsInitialized() const {

  return true;
}

void LidarBaseInfo::Swap(LidarBaseInfo* other) {
  if (other != this) {
    std::swap(vendor_name_, other->vendor_name_);
    std::swap(model_, other->model_);
    std::swap(ip_, other->ip_);
    std::swap(desc_, other->desc_);
    std::swap(port_, other->port_);
    std::swap(rpm_, other->rpm_);
    std::swap(time_offset_, other->time_offset_);
    std::swap(repeat_delay_, other->repeat_delay_);
    std::swap(max_range_, other->max_range_);
    std::swap(min_range_, other->min_range_);
    std::swap(view_direction_, other->view_direction_);
    std::swap(view_width_, other->view_width_);
    std::swap(min_angle_, other->min_angle_);
    std::swap(max_angle_, other->max_angle_);
    std::swap(packet_rate_, other->packet_rate_);
    std::swap(pitch_, other->pitch_);
    std::swap(yaw_, other->yaw_);
    std::swap(roll_, other->roll_);
    std::swap(x_offset_, other->x_offset_);
    std::swap(y_offset_, other->y_offset_);
    std::swap(z_offset_, other->z_offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LidarBaseInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LidarBaseInfo_descriptor_;
  metadata.reflection = LidarBaseInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VelodyneLaserParam::kIdFieldNumber;
const int VelodyneLaserParam::kDistCorrectionFieldNumber;
const int VelodyneLaserParam::kDistCorrectionXFieldNumber;
const int VelodyneLaserParam::kDistCorrectionYFieldNumber;
const int VelodyneLaserParam::kFocalDistanceFieldNumber;
const int VelodyneLaserParam::kFocalSlopeFieldNumber;
const int VelodyneLaserParam::kHorizOffsetCorrectionFieldNumber;
const int VelodyneLaserParam::kRotCorrectionFieldNumber;
const int VelodyneLaserParam::kVertCorrectionFieldNumber;
const int VelodyneLaserParam::kVertOffsetCorrectionFieldNumber;
const int VelodyneLaserParam::kMaxIntensityFieldNumber;
const int VelodyneLaserParam::kMinIntensityFieldNumber;
#endif  // !_MSC_VER

VelodyneLaserParam::VelodyneLaserParam()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.VelodyneLaserParam)
}

void VelodyneLaserParam::InitAsDefaultInstance() {
}

VelodyneLaserParam::VelodyneLaserParam(const VelodyneLaserParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.VelodyneLaserParam)
}

void VelodyneLaserParam::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  dist_correction_ = 0;
  dist_correction_x_ = 0;
  dist_correction_y_ = 0;
  focal_distance_ = 0;
  focal_slope_ = 0;
  horiz_offset_correction_ = 0;
  rot_correction_ = 0;
  vert_correction_ = 0;
  vert_offset_correction_ = 0;
  max_intensity_ = 0;
  min_intensity_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VelodyneLaserParam::~VelodyneLaserParam() {
  // @@protoc_insertion_point(destructor:SensorProto.VelodyneLaserParam)
  SharedDtor();
}

void VelodyneLaserParam::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VelodyneLaserParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VelodyneLaserParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VelodyneLaserParam_descriptor_;
}

const VelodyneLaserParam& VelodyneLaserParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

VelodyneLaserParam* VelodyneLaserParam::default_instance_ = NULL;

VelodyneLaserParam* VelodyneLaserParam::New() const {
  return new VelodyneLaserParam;
}

void VelodyneLaserParam::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VelodyneLaserParam*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, rot_correction_);
  }
  ZR_(vert_correction_, min_intensity_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VelodyneLaserParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.VelodyneLaserParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_dist_correction;
        break;
      }

      // optional float dist_correction = 2;
      case 2: {
        if (tag == 21) {
         parse_dist_correction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dist_correction_)));
          set_has_dist_correction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_dist_correction_x;
        break;
      }

      // optional float dist_correction_x = 3;
      case 3: {
        if (tag == 29) {
         parse_dist_correction_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dist_correction_x_)));
          set_has_dist_correction_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_dist_correction_y;
        break;
      }

      // optional float dist_correction_y = 4;
      case 4: {
        if (tag == 37) {
         parse_dist_correction_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dist_correction_y_)));
          set_has_dist_correction_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_focal_distance;
        break;
      }

      // optional float focal_distance = 5;
      case 5: {
        if (tag == 45) {
         parse_focal_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_distance_)));
          set_has_focal_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_focal_slope;
        break;
      }

      // optional float focal_slope = 6;
      case 6: {
        if (tag == 53) {
         parse_focal_slope:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_slope_)));
          set_has_focal_slope();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_horiz_offset_correction;
        break;
      }

      // optional float horiz_offset_correction = 7;
      case 7: {
        if (tag == 61) {
         parse_horiz_offset_correction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &horiz_offset_correction_)));
          set_has_horiz_offset_correction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_rot_correction;
        break;
      }

      // optional float rot_correction = 8;
      case 8: {
        if (tag == 69) {
         parse_rot_correction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rot_correction_)));
          set_has_rot_correction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_vert_correction;
        break;
      }

      // optional float vert_correction = 9;
      case 9: {
        if (tag == 77) {
         parse_vert_correction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vert_correction_)));
          set_has_vert_correction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_vert_offset_correction;
        break;
      }

      // optional float vert_offset_correction = 10;
      case 10: {
        if (tag == 85) {
         parse_vert_offset_correction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vert_offset_correction_)));
          set_has_vert_offset_correction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_max_intensity;
        break;
      }

      // optional float max_intensity = 11;
      case 11: {
        if (tag == 93) {
         parse_max_intensity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_intensity_)));
          set_has_max_intensity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_min_intensity;
        break;
      }

      // optional float min_intensity = 12;
      case 12: {
        if (tag == 101) {
         parse_min_intensity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_intensity_)));
          set_has_min_intensity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.VelodyneLaserParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.VelodyneLaserParam)
  return false;
#undef DO_
}

void VelodyneLaserParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.VelodyneLaserParam)
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional float dist_correction = 2;
  if (has_dist_correction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->dist_correction(), output);
  }

  // optional float dist_correction_x = 3;
  if (has_dist_correction_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->dist_correction_x(), output);
  }

  // optional float dist_correction_y = 4;
  if (has_dist_correction_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->dist_correction_y(), output);
  }

  // optional float focal_distance = 5;
  if (has_focal_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->focal_distance(), output);
  }

  // optional float focal_slope = 6;
  if (has_focal_slope()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->focal_slope(), output);
  }

  // optional float horiz_offset_correction = 7;
  if (has_horiz_offset_correction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->horiz_offset_correction(), output);
  }

  // optional float rot_correction = 8;
  if (has_rot_correction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->rot_correction(), output);
  }

  // optional float vert_correction = 9;
  if (has_vert_correction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->vert_correction(), output);
  }

  // optional float vert_offset_correction = 10;
  if (has_vert_offset_correction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->vert_offset_correction(), output);
  }

  // optional float max_intensity = 11;
  if (has_max_intensity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->max_intensity(), output);
  }

  // optional float min_intensity = 12;
  if (has_min_intensity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->min_intensity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.VelodyneLaserParam)
}

::google::protobuf::uint8* VelodyneLaserParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.VelodyneLaserParam)
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional float dist_correction = 2;
  if (has_dist_correction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->dist_correction(), target);
  }

  // optional float dist_correction_x = 3;
  if (has_dist_correction_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->dist_correction_x(), target);
  }

  // optional float dist_correction_y = 4;
  if (has_dist_correction_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->dist_correction_y(), target);
  }

  // optional float focal_distance = 5;
  if (has_focal_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->focal_distance(), target);
  }

  // optional float focal_slope = 6;
  if (has_focal_slope()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->focal_slope(), target);
  }

  // optional float horiz_offset_correction = 7;
  if (has_horiz_offset_correction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->horiz_offset_correction(), target);
  }

  // optional float rot_correction = 8;
  if (has_rot_correction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->rot_correction(), target);
  }

  // optional float vert_correction = 9;
  if (has_vert_correction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->vert_correction(), target);
  }

  // optional float vert_offset_correction = 10;
  if (has_vert_offset_correction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->vert_offset_correction(), target);
  }

  // optional float max_intensity = 11;
  if (has_max_intensity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->max_intensity(), target);
  }

  // optional float min_intensity = 12;
  if (has_min_intensity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->min_intensity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.VelodyneLaserParam)
  return target;
}

int VelodyneLaserParam::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional float dist_correction = 2;
    if (has_dist_correction()) {
      total_size += 1 + 4;
    }

    // optional float dist_correction_x = 3;
    if (has_dist_correction_x()) {
      total_size += 1 + 4;
    }

    // optional float dist_correction_y = 4;
    if (has_dist_correction_y()) {
      total_size += 1 + 4;
    }

    // optional float focal_distance = 5;
    if (has_focal_distance()) {
      total_size += 1 + 4;
    }

    // optional float focal_slope = 6;
    if (has_focal_slope()) {
      total_size += 1 + 4;
    }

    // optional float horiz_offset_correction = 7;
    if (has_horiz_offset_correction()) {
      total_size += 1 + 4;
    }

    // optional float rot_correction = 8;
    if (has_rot_correction()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float vert_correction = 9;
    if (has_vert_correction()) {
      total_size += 1 + 4;
    }

    // optional float vert_offset_correction = 10;
    if (has_vert_offset_correction()) {
      total_size += 1 + 4;
    }

    // optional float max_intensity = 11;
    if (has_max_intensity()) {
      total_size += 1 + 4;
    }

    // optional float min_intensity = 12;
    if (has_min_intensity()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VelodyneLaserParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VelodyneLaserParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VelodyneLaserParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VelodyneLaserParam::MergeFrom(const VelodyneLaserParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_dist_correction()) {
      set_dist_correction(from.dist_correction());
    }
    if (from.has_dist_correction_x()) {
      set_dist_correction_x(from.dist_correction_x());
    }
    if (from.has_dist_correction_y()) {
      set_dist_correction_y(from.dist_correction_y());
    }
    if (from.has_focal_distance()) {
      set_focal_distance(from.focal_distance());
    }
    if (from.has_focal_slope()) {
      set_focal_slope(from.focal_slope());
    }
    if (from.has_horiz_offset_correction()) {
      set_horiz_offset_correction(from.horiz_offset_correction());
    }
    if (from.has_rot_correction()) {
      set_rot_correction(from.rot_correction());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_vert_correction()) {
      set_vert_correction(from.vert_correction());
    }
    if (from.has_vert_offset_correction()) {
      set_vert_offset_correction(from.vert_offset_correction());
    }
    if (from.has_max_intensity()) {
      set_max_intensity(from.max_intensity());
    }
    if (from.has_min_intensity()) {
      set_min_intensity(from.min_intensity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VelodyneLaserParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VelodyneLaserParam::CopyFrom(const VelodyneLaserParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VelodyneLaserParam::IsInitialized() const {

  return true;
}

void VelodyneLaserParam::Swap(VelodyneLaserParam* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(dist_correction_, other->dist_correction_);
    std::swap(dist_correction_x_, other->dist_correction_x_);
    std::swap(dist_correction_y_, other->dist_correction_y_);
    std::swap(focal_distance_, other->focal_distance_);
    std::swap(focal_slope_, other->focal_slope_);
    std::swap(horiz_offset_correction_, other->horiz_offset_correction_);
    std::swap(rot_correction_, other->rot_correction_);
    std::swap(vert_correction_, other->vert_correction_);
    std::swap(vert_offset_correction_, other->vert_offset_correction_);
    std::swap(max_intensity_, other->max_intensity_);
    std::swap(min_intensity_, other->min_intensity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VelodyneLaserParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VelodyneLaserParam_descriptor_;
  metadata.reflection = VelodyneLaserParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VelodyneLasers::kNumFieldNumber;
const int VelodyneLasers::kParamFieldNumber;
#endif  // !_MSC_VER

VelodyneLasers::VelodyneLasers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.VelodyneLasers)
}

void VelodyneLasers::InitAsDefaultInstance() {
}

VelodyneLasers::VelodyneLasers(const VelodyneLasers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.VelodyneLasers)
}

void VelodyneLasers::SharedCtor() {
  _cached_size_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VelodyneLasers::~VelodyneLasers() {
  // @@protoc_insertion_point(destructor:SensorProto.VelodyneLasers)
  SharedDtor();
}

void VelodyneLasers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VelodyneLasers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VelodyneLasers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VelodyneLasers_descriptor_;
}

const VelodyneLasers& VelodyneLasers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

VelodyneLasers* VelodyneLasers::default_instance_ = NULL;

VelodyneLasers* VelodyneLasers::New() const {
  return new VelodyneLasers;
}

void VelodyneLasers::Clear() {
  num_ = 0;
  param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VelodyneLasers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.VelodyneLasers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        break;
      }

      // repeated .SensorProto.VelodyneLaserParam param = 2;
      case 2: {
        if (tag == 18) {
         parse_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.VelodyneLasers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.VelodyneLasers)
  return false;
#undef DO_
}

void VelodyneLasers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.VelodyneLasers)
  // optional int32 num = 1;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num(), output);
  }

  // repeated .SensorProto.VelodyneLaserParam param = 2;
  for (int i = 0; i < this->param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->param(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.VelodyneLasers)
}

::google::protobuf::uint8* VelodyneLasers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.VelodyneLasers)
  // optional int32 num = 1;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->num(), target);
  }

  // repeated .SensorProto.VelodyneLaserParam param = 2;
  for (int i = 0; i < this->param_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->param(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.VelodyneLasers)
  return target;
}

int VelodyneLasers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 num = 1;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  // repeated .SensorProto.VelodyneLaserParam param = 2;
  total_size += 1 * this->param_size();
  for (int i = 0; i < this->param_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->param(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VelodyneLasers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VelodyneLasers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VelodyneLasers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VelodyneLasers::MergeFrom(const VelodyneLasers& from) {
  GOOGLE_CHECK_NE(&from, this);
  param_.MergeFrom(from.param_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VelodyneLasers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VelodyneLasers::CopyFrom(const VelodyneLasers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VelodyneLasers::IsInitialized() const {

  return true;
}

void VelodyneLasers::Swap(VelodyneLasers* other) {
  if (other != this) {
    std::swap(num_, other->num_);
    param_.Swap(&other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VelodyneLasers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VelodyneLasers_descriptor_;
  metadata.reflection = VelodyneLasers_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VelodyneParmas::kBaseInfoFieldNumber;
const int VelodyneParmas::kLasersFieldNumber;
#endif  // !_MSC_VER

VelodyneParmas::VelodyneParmas()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.VelodyneParmas)
}

void VelodyneParmas::InitAsDefaultInstance() {
  base_info_ = const_cast< ::SensorProto::LidarBaseInfo*>(&::SensorProto::LidarBaseInfo::default_instance());
  lasers_ = const_cast< ::SensorProto::VelodyneLasers*>(&::SensorProto::VelodyneLasers::default_instance());
}

VelodyneParmas::VelodyneParmas(const VelodyneParmas& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.VelodyneParmas)
}

void VelodyneParmas::SharedCtor() {
  _cached_size_ = 0;
  base_info_ = NULL;
  lasers_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VelodyneParmas::~VelodyneParmas() {
  // @@protoc_insertion_point(destructor:SensorProto.VelodyneParmas)
  SharedDtor();
}

void VelodyneParmas::SharedDtor() {
  if (this != default_instance_) {
    delete base_info_;
    delete lasers_;
  }
}

void VelodyneParmas::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VelodyneParmas::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VelodyneParmas_descriptor_;
}

const VelodyneParmas& VelodyneParmas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

VelodyneParmas* VelodyneParmas::default_instance_ = NULL;

VelodyneParmas* VelodyneParmas::New() const {
  return new VelodyneParmas;
}

void VelodyneParmas::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_base_info()) {
      if (base_info_ != NULL) base_info_->::SensorProto::LidarBaseInfo::Clear();
    }
    if (has_lasers()) {
      if (lasers_ != NULL) lasers_->::SensorProto::VelodyneLasers::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VelodyneParmas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.VelodyneParmas)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SensorProto.LidarBaseInfo base_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lasers;
        break;
      }

      // optional .SensorProto.VelodyneLasers lasers = 2;
      case 2: {
        if (tag == 18) {
         parse_lasers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lasers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.VelodyneParmas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.VelodyneParmas)
  return false;
#undef DO_
}

void VelodyneParmas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.VelodyneParmas)
  // optional .SensorProto.LidarBaseInfo base_info = 1;
  if (has_base_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base_info(), output);
  }

  // optional .SensorProto.VelodyneLasers lasers = 2;
  if (has_lasers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lasers(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.VelodyneParmas)
}

::google::protobuf::uint8* VelodyneParmas::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.VelodyneParmas)
  // optional .SensorProto.LidarBaseInfo base_info = 1;
  if (has_base_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base_info(), target);
  }

  // optional .SensorProto.VelodyneLasers lasers = 2;
  if (has_lasers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lasers(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.VelodyneParmas)
  return target;
}

int VelodyneParmas::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .SensorProto.LidarBaseInfo base_info = 1;
    if (has_base_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base_info());
    }

    // optional .SensorProto.VelodyneLasers lasers = 2;
    if (has_lasers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lasers());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VelodyneParmas::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VelodyneParmas* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VelodyneParmas*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VelodyneParmas::MergeFrom(const VelodyneParmas& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base_info()) {
      mutable_base_info()->::SensorProto::LidarBaseInfo::MergeFrom(from.base_info());
    }
    if (from.has_lasers()) {
      mutable_lasers()->::SensorProto::VelodyneLasers::MergeFrom(from.lasers());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VelodyneParmas::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VelodyneParmas::CopyFrom(const VelodyneParmas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VelodyneParmas::IsInitialized() const {

  return true;
}

void VelodyneParmas::Swap(VelodyneParmas* other) {
  if (other != this) {
    std::swap(base_info_, other->base_info_);
    std::swap(lasers_, other->lasers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VelodyneParmas::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VelodyneParmas_descriptor_;
  metadata.reflection = VelodyneParmas_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VelodyneFrame::kTimeStampFieldNumber;
const int VelodyneFrame::kParmsFieldNumber;
#endif  // !_MSC_VER

VelodyneFrame::VelodyneFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.VelodyneFrame)
}

void VelodyneFrame::InitAsDefaultInstance() {
  parms_ = const_cast< ::SensorProto::VelodyneParmas*>(&::SensorProto::VelodyneParmas::default_instance());
}

VelodyneFrame::VelodyneFrame(const VelodyneFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.VelodyneFrame)
}

void VelodyneFrame::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  parms_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VelodyneFrame::~VelodyneFrame() {
  // @@protoc_insertion_point(destructor:SensorProto.VelodyneFrame)
  SharedDtor();
}

void VelodyneFrame::SharedDtor() {
  if (this != default_instance_) {
    delete parms_;
  }
}

void VelodyneFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VelodyneFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VelodyneFrame_descriptor_;
}

const VelodyneFrame& VelodyneFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

VelodyneFrame* VelodyneFrame::default_instance_ = NULL;

VelodyneFrame* VelodyneFrame::New() const {
  return new VelodyneFrame;
}

void VelodyneFrame::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    time_stamp_ = GOOGLE_LONGLONG(0);
    if (has_parms()) {
      if (parms_ != NULL) parms_->::SensorProto::VelodyneParmas::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VelodyneFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.VelodyneFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parms;
        break;
      }

      // optional .SensorProto.VelodyneParmas parms = 2;
      case 2: {
        if (tag == 18) {
         parse_parms:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parms()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.VelodyneFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.VelodyneFrame)
  return false;
#undef DO_
}

void VelodyneFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.VelodyneFrame)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->time_stamp(), output);
  }

  // optional .SensorProto.VelodyneParmas parms = 2;
  if (has_parms()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parms(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.VelodyneFrame)
}

::google::protobuf::uint8* VelodyneFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.VelodyneFrame)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->time_stamp(), target);
  }

  // optional .SensorProto.VelodyneParmas parms = 2;
  if (has_parms()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parms(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.VelodyneFrame)
  return target;
}

int VelodyneFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional .SensorProto.VelodyneParmas parms = 2;
    if (has_parms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parms());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VelodyneFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VelodyneFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VelodyneFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VelodyneFrame::MergeFrom(const VelodyneFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_parms()) {
      mutable_parms()->::SensorProto::VelodyneParmas::MergeFrom(from.parms());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VelodyneFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VelodyneFrame::CopyFrom(const VelodyneFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VelodyneFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void VelodyneFrame::Swap(VelodyneFrame* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(parms_, other->parms_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VelodyneFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VelodyneFrame_descriptor_;
  metadata.reflection = VelodyneFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobosenseParmas::kBaseInfoFieldNumber;
const int RobosenseParmas::kServerIpFieldNumber;
#endif  // !_MSC_VER

RobosenseParmas::RobosenseParmas()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.RobosenseParmas)
}

void RobosenseParmas::InitAsDefaultInstance() {
  base_info_ = const_cast< ::SensorProto::LidarBaseInfo*>(&::SensorProto::LidarBaseInfo::default_instance());
}

RobosenseParmas::RobosenseParmas(const RobosenseParmas& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.RobosenseParmas)
}

void RobosenseParmas::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  base_info_ = NULL;
  server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobosenseParmas::~RobosenseParmas() {
  // @@protoc_insertion_point(destructor:SensorProto.RobosenseParmas)
  SharedDtor();
}

void RobosenseParmas::SharedDtor() {
  if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_ip_;
  }
  if (this != default_instance_) {
    delete base_info_;
  }
}

void RobosenseParmas::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobosenseParmas::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobosenseParmas_descriptor_;
}

const RobosenseParmas& RobosenseParmas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

RobosenseParmas* RobosenseParmas::default_instance_ = NULL;

RobosenseParmas* RobosenseParmas::New() const {
  return new RobosenseParmas;
}

void RobosenseParmas::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_base_info()) {
      if (base_info_ != NULL) base_info_->::SensorProto::LidarBaseInfo::Clear();
    }
    if (has_server_ip()) {
      if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        server_ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobosenseParmas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.RobosenseParmas)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SensorProto.LidarBaseInfo base_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_server_ip;
        break;
      }

      // optional string server_ip = 2;
      case 2: {
        if (tag == 18) {
         parse_server_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->server_ip().data(), this->server_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "server_ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.RobosenseParmas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.RobosenseParmas)
  return false;
#undef DO_
}

void RobosenseParmas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.RobosenseParmas)
  // optional .SensorProto.LidarBaseInfo base_info = 1;
  if (has_base_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base_info(), output);
  }

  // optional string server_ip = 2;
  if (has_server_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->server_ip().data(), this->server_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "server_ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->server_ip(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.RobosenseParmas)
}

::google::protobuf::uint8* RobosenseParmas::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.RobosenseParmas)
  // optional .SensorProto.LidarBaseInfo base_info = 1;
  if (has_base_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base_info(), target);
  }

  // optional string server_ip = 2;
  if (has_server_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->server_ip().data(), this->server_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "server_ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->server_ip(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.RobosenseParmas)
  return target;
}

int RobosenseParmas::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .SensorProto.LidarBaseInfo base_info = 1;
    if (has_base_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base_info());
    }

    // optional string server_ip = 2;
    if (has_server_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server_ip());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobosenseParmas::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobosenseParmas* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobosenseParmas*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobosenseParmas::MergeFrom(const RobosenseParmas& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base_info()) {
      mutable_base_info()->::SensorProto::LidarBaseInfo::MergeFrom(from.base_info());
    }
    if (from.has_server_ip()) {
      set_server_ip(from.server_ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobosenseParmas::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobosenseParmas::CopyFrom(const RobosenseParmas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobosenseParmas::IsInitialized() const {

  return true;
}

void RobosenseParmas::Swap(RobosenseParmas* other) {
  if (other != this) {
    std::swap(base_info_, other->base_info_);
    std::swap(server_ip_, other->server_ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobosenseParmas::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobosenseParmas_descriptor_;
  metadata.reflection = RobosenseParmas_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobosenseFrame::kTimeStampFieldNumber;
const int RobosenseFrame::kParmsFieldNumber;
#endif  // !_MSC_VER

RobosenseFrame::RobosenseFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorProto.RobosenseFrame)
}

void RobosenseFrame::InitAsDefaultInstance() {
  parms_ = const_cast< ::SensorProto::RobosenseParmas*>(&::SensorProto::RobosenseParmas::default_instance());
}

RobosenseFrame::RobosenseFrame(const RobosenseFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorProto.RobosenseFrame)
}

void RobosenseFrame::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  parms_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobosenseFrame::~RobosenseFrame() {
  // @@protoc_insertion_point(destructor:SensorProto.RobosenseFrame)
  SharedDtor();
}

void RobosenseFrame::SharedDtor() {
  if (this != default_instance_) {
    delete parms_;
  }
}

void RobosenseFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobosenseFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobosenseFrame_descriptor_;
}

const RobosenseFrame& RobosenseFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_sensor_2eproto();
  return *default_instance_;
}

RobosenseFrame* RobosenseFrame::default_instance_ = NULL;

RobosenseFrame* RobosenseFrame::New() const {
  return new RobosenseFrame;
}

void RobosenseFrame::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    time_stamp_ = GOOGLE_LONGLONG(0);
    if (has_parms()) {
      if (parms_ != NULL) parms_->::SensorProto::RobosenseParmas::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobosenseFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorProto.RobosenseFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parms;
        break;
      }

      // optional .SensorProto.RobosenseParmas parms = 2;
      case 2: {
        if (tag == 18) {
         parse_parms:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parms()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorProto.RobosenseFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorProto.RobosenseFrame)
  return false;
#undef DO_
}

void RobosenseFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorProto.RobosenseFrame)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->time_stamp(), output);
  }

  // optional .SensorProto.RobosenseParmas parms = 2;
  if (has_parms()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parms(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorProto.RobosenseFrame)
}

::google::protobuf::uint8* RobosenseFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorProto.RobosenseFrame)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->time_stamp(), target);
  }

  // optional .SensorProto.RobosenseParmas parms = 2;
  if (has_parms()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parms(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorProto.RobosenseFrame)
  return target;
}

int RobosenseFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional .SensorProto.RobosenseParmas parms = 2;
    if (has_parms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parms());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobosenseFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobosenseFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobosenseFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobosenseFrame::MergeFrom(const RobosenseFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_parms()) {
      mutable_parms()->::SensorProto::RobosenseParmas::MergeFrom(from.parms());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobosenseFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobosenseFrame::CopyFrom(const RobosenseFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobosenseFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RobosenseFrame::Swap(RobosenseFrame* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(parms_, other->parms_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobosenseFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobosenseFrame_descriptor_;
  metadata.reflection = RobosenseFrame_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SensorProto

// @@protoc_insertion_point(global_scope)
